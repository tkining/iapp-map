window.gMapsCallback = function() {
    $(window).trigger("gMapsCallback")
};
(function(k, t, v, w) {
    function p(a, b) {
        var d = {
                lat: "",
                lng: ""
            },
            c = [],
            e = /^[+-]?\d+(\.\d+)?$/;
        if ("string" === typeof a || Array.isArray(a))
            if (c = Array.isArray(a) ? a : a.toString().replace(/\s+/, "").split(","), 2 === c.length) e.test(c[0]) && e.test(c[1]) && (d.lat = c[0], d.lng = c[1]);
            else return a;
        else if ("object" === typeof a) {
            if ("function" === typeof a.lat) return a;
            a.hasOwnProperty("x") && a.hasOwnProperty("y") ? (d.lat = a.x, d.lng = a.y) : a.hasOwnProperty("lat") && a.hasOwnProperty("lng") && (d.lat = a.lat, d.lng = a.lng)
        }
        return !0 === b ? new google.maps.LatLng(d.lat,
            d.lng) : d
    }

    function x(a, b) {
        var d = this,
            c = k.extend({}, B, b);
        d.map = null;
        d._markers = [];
        d._markersCluster = [];
        d._clusters = [];
        d._labels = [];
        d._polylines = [];
        d._polygons = [];
        d._circles = [];
        d._kmls = [];
        d._directions = [];
        d._directionsMarkers = [];
        d._places = [];
        d.container = a;
        d.options = c;
        d.googleMapOptions = {};
        d.interval = parseInt(d.options.interval, 10) || 200;
        k(t).on("gMapsCallback", function() {
            d.init()
        });
        k(this.container).html(c.loading);
        d.init()
    }
    var z = !1,
        A = !1,
        r = {
            sensor: !1,
            language: "zh-TW",
            callback: "gMapsCallback",
            api: "//maps.google.com/maps/api/js",
            clusterer: "//google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/src/markerclusterer_compiled.js"
        },
        B = {
            autoLocation: !1,
            center: [24, 121],
            infoWindowAutoClose: !0,
            interval: 200,
            loading: "\u8b80\u53d6\u4e2d&hellip;",
            notFound: "\u627e\u4e0d\u5230\u67e5\u8a62\u7684\u5730\u9ede",
            zoom: 8
        },
        y = {},
        u = {},
        y = {
            greyscale: [{
                featureType: "all",
                stylers: [{
                    saturation: -100
                }, {
                    gamma: .5
                }]
            }]
        };
    x.prototype = {
        VERSION: "3.2.3",
        bounds: {},
        overlay: function() {
            var a = this.map,
                b = this.options;
            try {
                this.kml(a, b), this.direction(a,
                    b), this.markers(a, b), this.drawPolyline(a, b), this.drawPolygon(a, b), this.drawCircle(a, b), this.streetView(a, b), this.places(a, b), this.geoLocation(a, b)
            } catch (d) {
                console.info(d)
            }
        },
        bindEvents: function(a, b) {
            var d = this,
                c = {};
            switch (typeof b) {
                case "function":
                    google.maps.event.addListener(a, "click", b);
                    break;
                case "object":
                    for (c in b) "function" === typeof b[c] ? google.maps.event.addListener(a, c, b[c]) : b[c].hasOwnProperty("func") && "function" === typeof b[c].func ? b[c].hasOwnProperty("once") && !0 === b[c].once ? google.maps.event.addListenerOnce(a,
                        c, b[c].func) : google.maps.event.addListener(a, c, b[c].func) : "function" === typeof b[c] && google.maps.event.addListener(a, c, b[c])
            }
            a.hasOwnProperty("infoWindow") && google.maps.event.addListener(a, "click", function() {
                var b = 0,
                    c = {};
                if (d.options.hasOwnProperty("infoWindowAutoClose") && !0 === d.options.infoWindowAutoClose)
                    for (b = d._markers.length - 1; 0 <= b; --b) c = d._markers[b], c.hasOwnProperty("infoWindow") && "function" === typeof c.infoWindow.close && c.infoWindow.close();
                a.infoWindow.open(d.map, a)
            })
        },
        kml: function(a, b) {
            var d = {
                    url: "",
                    map: a,
                    preserveViewport: !1,
                    suppressInfoWindows: !1
                },
                c = {},
                e = 0;
            if (b.hasOwnProperty("kml"))
                if ("string" === typeof b.kml) d.url = b.kml, c = new google.maps.KmlLayer(d), this._kmls.push(c);
                else if (Array.isArray(b.kml))
                for (e = b.kml.length - 1; 0 <= e; --e) "string" === typeof b.kml[e] ? (d.url = b.kml[e], c = new google.maps.KmlLayer(d)) : "object" === typeof b.kml[e] && (d = k.extend({}, d, b.kml[e]), c = new google.maps.KmlLayer(d), d.hasOwnProperty("event") && this.bindEvents(c, d.event)), this._kmls.push(c)
        },
        drawPolyline: function(a, b) {
            var d = {},
                c = [],
                e = {},
                f = {},
                g = {},
                g = {},
                h = [],
                q = [],
                n = 0,
                g = {},
                g = {},
                l = 0;
            routeCallback = function(a, b) {
                if (b === google.maps.DirectionsStatus.OK) {
                    for (l = a.routes[0].overview_path.length - 1; 0 <= l; --l) q.push(a.routes[0].overview_path[l]);
                    e.setPath(q);
                    "function" === typeof d.getDistance && (f = a.routes[0].legs[0].distance, d.getDistance.call(this, f))
                }
            };
            if (b.hasOwnProperty("polyline") && Array.isArray(b.polyline))
                for (n = 0; n < b.polyline.length; n += 1)
                    if (d = b.polyline[n], d.hasOwnProperty("coords") && Array.isArray(d.coords)) {
                        h = new google.maps.MVCArray;
                        for (l = d.coords.length - 1; 0 <= l; --l) g = d.coords[l], g = p(g, !0), "function" === typeof g.lat && h.push(g);
                        g = k.extend({}, {
                            strokeColor: d.color || "#FF0000",
                            strokeOpacity: d.opacity || 1,
                            strokeWeight: d.width || 2
                        }, d);
                        e = new google.maps.Polyline(g);
                        this._polylines.push(e);
                        if (2 < h.getLength())
                            for (l = h.length - 1; 0 <= l; --l) 0 < l && h.length - 1 > l && c.push({
                                location: h.getAt(l),
                                stopover: !1
                            });
                        e && g.hasOwnProperty("event") && g.event.hasOwnProperty("created") && "function" === typeof g.event.created && g.event.created.call(e, this);
                        d.hasOwnProperty("event") &&
                            this.bindEvents(e, d.event);
                        d.hasOwnProperty("snap") && !0 === d.snap ? (g = new google.maps.DirectionsService, g.route({
                            origin: h.getAt(0),
                            waypoints: c,
                            destination: h.getAt(h.length - 1),
                            travelMode: google.maps.DirectionsTravelMode.DRIVING
                        }, routeCallback)) : (e.setPath(h), google.maps.hasOwnProperty("geometry") && google.maps.geometry.hasOwnProperty("spherical") && "function" === typeof google.maps.geometry.spherical.computeDistanceBetween && (f = google.maps.geometry.spherical.computeDistanceBetween(h.getAt(0), h.getAt(h.length -
                            1)), "function" === typeof d.getDistance && d.getDistance.call(this, f)));
                        e.setMap(a)
                    }
        },
        drawPolygon: function(a, b) {
            var d = {},
                c = {},
                d = [],
                e = 0,
                c = 0,
                f = {},
                f = {};
            if (b.hasOwnProperty("polygon") && Array.isArray(b.polygon))
                for (e = 0; e < b.polygon.length; e += 1)
                    if (d = [], b.polygon[e].hasOwnProperty("coords")) {
                        for (c = 0; c < b.polygon[e].coords.length; c += 1) f = b.polygon[e].coords[c], f = p(f, !0), "function" === typeof f.lat && d.push(f);
                        c = k.extend({}, {
                            path: d,
                            strokeColor: b.polygon[e].color || "#FF0000",
                            strokeOpacity: 1,
                            strokeWeight: b.polygon[e].width ||
                                2,
                            fillColor: b.polygon[e].fillcolor || "#CC0000",
                            fillOpacity: .35
                        }, b.polygon[e]);
                        (d = new google.maps.Polygon(c)) && c.hasOwnProperty("event") && c.event.hasOwnProperty("created") && "function" === typeof c.event.created && c.event.created.call(d, this);
                        c.hasOwnProperty("event") && this.bindEvents(d, c.event);
                        this._polygons.push(d);
                        d.setMap(a)
                    }
        },
        drawCircle: function(a, b) {
            var d = {},
                c = {},
                e = {},
                f = {},
                g = 0;
            if (b.hasOwnProperty("circle") && Array.isArray(b.circle))
                for (g = 0; g < b.circle.length; g += 1) c = b.circle[g], e = k.extend({}, {
                    map: a,
                    strokeColor: c.color || "#FF0000",
                    strokeOpacity: c.opacity || .8,
                    strokeWeight: c.width || 2,
                    fillColor: c.fillcolor || "#FF0000",
                    fillOpacity: c.fillopacity || .35,
                    radius: c.radius || 10,
                    zIndex: 100,
                    id: c.hasOwnProperty("id") ? c.id : ""
                }, c), c.hasOwnProperty("center") && (f = p(c.center, !0), e.center = f), "function" === typeof f.lat && (d = new google.maps.Circle(e), this._circles.push(d), d && e.hasOwnProperty("event") && e.event.hasOwnProperty("created") && "function" === typeof e.event.created && e.event.created.call(d, this), c.hasOwnProperty("event") &&
                    this.bindEvents(d, c.event))
        },
        markers: function(a, b, d) {
            if (!b.hasOwnProperty("marker") || !Array.isArray(b.marker)) return !1;
            var c = {},
                e = 0,
                f = 0,
                c = {},
                g = this._markers,
                h = this._labels,
                q = new google.maps.Geocoder,
                n = function(a, b) {
                    if (b === google.maps.GeocoderStatus.OK) g[f].setPosition(a[0].geometry.location);
                    else throw "Geocoder Status: " + b;
                };
            if (!d || 0 === g.length) {
                for (e = 0; e < b.marker.length; e += 1) c = b.marker[e], c.hasOwnProperty("addr") && (c.parseAddr = p(c.addr, !0), "string" === typeof c.parseAddr ? this.markerByGeocoder(a, c,
                    b) : this.markerDirect(a, c, b));
                d = w
            }
            if ("modify" === d)
                for (e = 0; e < b.marker.length; e += 1) {
                    if (b.marker[e].hasOwnProperty("id"))
                        for (f = 0; f < g.length; f += 1)
                            if (b.marker[e].id === g[f].id && b.marker[e].hasOwnProperty("addr")) c = p(b.marker[e].addr, !0), "string" === typeof c ? q.geocode({
                                address: c
                            }, n) : g[f].setPosition(c), b.marker[e].hasOwnProperty("text") && (g[f].hasOwnProperty("infoWindow") ? "function" === typeof g[f].infoWindow.setContent && g[f].infoWindow.setContent(b.marker[e].text) : (g[f].infoWindow = new google.maps.InfoWindow({
                                    content: b.marker[e].text
                                }),
                                this.bindEvents(g[f], b.marker[e].event))), b.marker[e].hasOwnProperty("icon") && g[f].setIcon(b.marker[e].icon);
                            else {
                                if (b.marker[e].hasOwnProperty("forceInsert") && !0 === b.marker[e].forceInsert && b.marker[e].hasOwnProperty("addr")) {
                                    b.marker[e].parseAddr = p(b.marker[e].addr, !0);
                                    "string" === typeof b.marker[e].parseAddr ? this.markerByGeocoder(a, b.marker[e], b) : this.markerDirect(a, b.marker[e]);
                                    break
                                }
                            } else b.marker[e].hasOwnProperty("addr") && (b.marker[e].parseAddr = p(b.marker[e].addr, !0), "string" === typeof b.marker[e].parseAddr ?
                        this.markerByGeocoder(a, b.marker[e]) : this.markerDirect(a, b.marker[e]));
                    for (f = 0; f < h.length; f += 1) b.marker[e].id === h[f].id && (b.marker[e].hasOwnProperty("label") && (h[f].text = b.marker[e].label), b.marker[e].hasOwnProperty("css") && k(h[f].span).addClass(b.marker[e].css), h[f].draw())
                }
        },
        markerIcon: function(a) {
            var b = k.extend({}, a.icon);
            if (a.hasOwnProperty("icon")) {
                if ("string" === typeof a.icon) return a.icon;
                a.icon.hasOwnProperty("url") && (b.url = a.icon.url);
                a.icon.hasOwnProperty("size") && Array.isArray(a.icon.size) &&
                    2 === a.icon.size.length && (b.size = new google.maps.Size(a.icon.size[0], a.icon.size[1]));
                a.icon.hasOwnProperty("scaledSize") && Array.isArray(a.icon.scaledSize) && 2 === a.icon.scaledSize.length && (b.scaledSize = new google.maps.Size(a.icon.scaledSize[0], a.icon.scaledSize[1]));
                a.icon.hasOwnProperty("anchor") && Array.isArray(a.icon.anchor) && 2 === a.icon.anchor.length && (b.anchor = new google.maps.Point(a.icon.anchor[0], a.icon.anchor[1]))
            }
            return b
        },
        markerDirect: function(a, b) {
            var d = {},
                c = {},
                c = b.hasOwnProperty("id") ? b.id :
                "",
                d = b.hasOwnProperty("title") ? b.title.toString().replace(/<([^>]+)>/g, "") : !1,
                e = b.hasOwnProperty("text") ? b.text.toString() : !1,
                f = this.markerIcon(b),
                g = {
                    maxZoom: null,
                    gridSize: 60
                },
                h = k.extend({}, {
                    map: a,
                    position: b.parseAddr,
                    animation: null,
                    id: c
                }, b);
            d && (h.title = d);
            e && (h.text = e, h.infoWindow = new google.maps.InfoWindow({
                content: e
            }));
            k.isEmptyObject(f) || (h.icon = f);
            b.hasOwnProperty("animation") && "string" === typeof b.animation && (h.animation = google.maps.Animation[b.animation.toUpperCase()]);
            d = new google.maps.Marker(h);
            this._markers.push(d);
            d && b.hasOwnProperty("event") && b.event.hasOwnProperty("created") && "function" === typeof b.event.created && b.event.created.call(d, this);
            d.hasOwnProperty("position") && ("function" === typeof d.getPosition && this.bounds.extend(d.position), this.options.hasOwnProperty("markerFitBounds") && !0 === this.options.markerFitBounds && this._markers.length === this.options.marker.length && a.fitBounds(this.bounds));
            (!b.hasOwnProperty("cluster") || b.hasOwnProperty("cluster") && !0 === b.cluster) && this._markersCluster.push(d);
            this.options.hasOwnProperty("markerCluster") && "function" === typeof MarkerClusterer && (g = k.extend({}, g, this.options.markerCluster), this._markers.length === this.options.marker.length && this._clusters.push(new MarkerClusterer(a, this._markersCluster, g)));
            b.hasOwnProperty("label") && (c = new u({
                text: b.label,
                map: a,
                css: b.hasOwnProperty("css") ? b.css.toString() : "",
                id: c
            }), c.bindTo("position", d, "position"), c.bindTo("text", d, "position"), c.bindTo("visible", d), this._labels.push(c));
            this.bindEvents(d, b.event)
        },
        markerByGeocoder: function(a,
            b, d) {
            var c = this;
            (new google.maps.Geocoder).geocode({
                address: b.parseAddr
            }, function(e, f) {
                if (f === google.maps.GeocoderStatus.OVER_QUERY_LIMIT) t.setTimeout(function() {
                    c.markerByGeocoder(a, b)
                }, c.interval);
                else if (f === google.maps.GeocoderStatus.OK) {
                    var g = {},
                        h = {},
                        h = b.hasOwnProperty("id") ? b.id : "",
                        g = b.hasOwnProperty("title") ? b.title.toString().replace(/<([^>]+)>/g, "") : !1,
                        q = b.hasOwnProperty("text") ? b.text.toString() : !1,
                        n = {
                            maxZoom: null,
                            gridSize: 60
                        },
                        l = {
                            map: a,
                            position: e[0].geometry.location,
                            animation: null,
                            visible: !0,
                            id: h
                        },
                        p = c.markerIcon(b);
                    g && (l.title = g);
                    q && (l.text = q, l.infoWindow = new google.maps.InfoWindow({
                        content: q
                    }));
                    k.isEmptyObject(p) || (l.icon = p);
                    b.hasOwnProperty("animation") && "string" === typeof b.animation && (l.animation = google.maps.Animation[b.animation.toUpperCase()]);
                    l = k.extend({}, l, b);
                    (g = new google.maps.Marker(l)) && b.hasOwnProperty("event") && b.event.hasOwnProperty("created") && "function" === typeof b.event.created && b.event.created.call(g, c);
                    c._markers.push(g);
                    g.hasOwnProperty("position") && ("function" === typeof g.getPosition &&
                        c.bounds.extend(g.position), c.options.hasOwnProperty("markerFitBounds") && !0 === c.options.markerFitBounds && c._markers.length === d.marker.length && a.fitBounds(c.bounds));
                    (!b.hasOwnProperty("cluster") || b.hasOwnProperty("cluster") && !0 === b.cluster) && c._markersCluster.push(g);
                    c.options.hasOwnProperty("markerCluster") && "function" === typeof MarkerClusterer && c._markers.length === d.marker.length && (n = k.extend({}, n, c.options.markerCluster), c._clusters.push(new MarkerClusterer(a, c._markersCluster, n)));
                    b.hasOwnProperty("label") &&
                        (h = new u({
                            text: b.label,
                            map: c.map,
                            css: b.hasOwnProperty("css") ? b.css.toString() : "",
                            id: h
                        }), h.bindTo("position", g, "position"), h.bindTo("text", g, "position"), h.bindTo("visible", g), c._labels.push(h));
                    c.bindEvents(g, b.event)
                }
            })
        },
        direction: function(a, b) {
            var d = 0;
            if (b.hasOwnProperty("direction") && Array.isArray(b.direction))
                for (d = 0; d < b.direction.length; --d) this.directionService(b.direction[d])
        },
        directionService: function(a) {
            if (a.hasOwnProperty("from") && a.hasOwnProperty("to")) {
                var b = this,
                    d = new google.maps.DirectionsService,
                    c = new google.maps.DirectionsRenderer,
                    e = {},
                    f = [],
                    g = [],
                    h = new google.maps.InfoWindow,
                    q = [],
                    n = {},
                    l = "",
                    t = "",
                    m = {
                        travelMode: google.maps.DirectionsTravelMode.DRIVING,
                        optimizeWaypoints: a.hasOwnProperty("optimize") ? a.optimize : !0
                    };
                i = 0;
                m.origin = p(a.from, !0);
                m.destination = p(a.to, !0);
                n = k.extend({}, {
                    infoWindow: h,
                    map: b.map
                }, a);
                a.hasOwnProperty("travel") && google.maps.TravelMode[a.travel.toString().toUpperCase()] && (m.travelMode = google.maps.TravelMode[a.travel.toString().toUpperCase()]);
                a.hasOwnProperty("panel") && k(a.panel).length &&
                    (n.panel = k(a.panel).get(0));
                if (a.hasOwnProperty("waypoint") && Array.isArray(a.waypoint)) {
                    for (i = 0; i < a.waypoint.length; i += 1) e = {}, "string" === typeof a.waypoint[i] || Array.isArray(a.waypoint[i]) ? e = {
                            location: p(a.waypoint[i], !0),
                            stopover: !0
                        } : (a.waypoint[i].hasOwnProperty("location") && (e.location = p(a.waypoint[i].location, !0)), e.stopover = a.waypoint[i].hasOwnProperty("stopover") ? a.waypoint[i].stopover : !0), f.push(a.waypoint[i].text || a.waypoint[i].toString()), a.waypoint[i].hasOwnProperty("icon") && g.push(a.waypoint[i].icon.toString()),
                        q.push(e);
                    m.waypoints = q
                }
                d.route(m, function(d, e) {
                    var k = [],
                        q = {},
                        m = 0;
                    if (e === google.maps.DirectionsStatus.OK) {
                        k = d.routes[0].legs;
                        try {
                            for (a.hasOwnProperty("fromText") && (l = k[0].start_address = a.fromText), a.hasOwnProperty("toText") && (1 === k.length ? k[0].end_address = a.toText : k[k.length - 1].end_address = a.toText, t = a.toText), a.hasOwnProperty("icon") && (n.suppressMarkers = !0, a.icon.hasOwnProperty("from") && "string" === typeof a.icon.from && b.directionServiceMarker(k[0].start_location, {
                                        icon: a.icon.from,
                                        text: l
                                    }, h, a), a.icon.hasOwnProperty("to") &&
                                    "string" === typeof a.icon.to && b.directionServiceMarker(k[k.length - 1].end_location, {
                                        icon: a.icon.to,
                                        text: t
                                    }, h, a)), m = k.length - 1; 0 <= m; --m) a.hasOwnProperty("icon") && (a.icon.hasOwnProperty("waypoint") && "string" === typeof a.icon.waypoint ? q.icon = a.icon.waypoint : "string" === typeof g[m - 1] && (q.icon = g[m - 1]), q.text = f[m - 1], b.directionServiceMarker(k[m].start_location, q, h, a))
                        } catch (p) {}
                        b.bindEvents(c, a.event);
                        c.setOptions(n);
                        c.setDirections(d)
                    }
                });
                b._directions.push(c)
            }
        },
        directionServiceMarker: function(a, b, d, c) {
            var e =
                this,
                f = {},
                g = k.extend({}, {
                    position: a,
                    map: e.map,
                    id: c.hasOwnProperty("id") ? c.id : ""
                }, b),
                h = new google.maps.Marker(g);
            g.hasOwnProperty("text") && (f = function() {
                d.setPosition(a);
                d.setContent(g.text);
                d.open(e.map, h)
            });
            e._directionsMarkers.push(h);
            e.bindEvents(h, f)
        },
        getDirectionsInfo: function() {
            var a = [],
                b = null,
                d = this._directions,
                c = 0,
                e = 0,
                f = 0,
                g = 0;
            if (d)
                for (f = 0, c = d.length; f < c; f += 1)
                    if (d[f].hasOwnProperty("directions") && d[f].directions.hasOwnProperty("routes") && "undefined" !== typeof d[f].directions.routes[0].legs)
                        for (b =
                            d[f].directions.routes[0].legs, a[f] = [], g = 0, e = b.length; g < e; g += 1) a[f].push({
                            from: b[g].start_address,
                            to: b[g].end_address,
                            distance: b[g].distance,
                            duration: b[g].duration
                        });
            return a
        },
        streetView: function(a, b) {
            var d = {},
                c = b.hasOwnProperty("streetViewObj") ? b.streetViewObj : {},
                e = {};
            "function" === typeof a.getStreetView && b.hasOwnProperty("streetViewObj") && (d = a.getStreetView(), c.hasOwnProperty("position") ? (e = p(c.position, !0), c.position = "object" === typeof e ? a.getCenter() : e) : c.position = a.getCenter(), c.hasOwnProperty("pov") &&
                (c.pov = k.extend({}, {
                    heading: 0,
                    pitch: 0,
                    zoom: 1
                }, c.pov)), c.hasOwnProperty("visible") && d.setVisible(c.visible), d.setOptions(c), c.hasOwnProperty("event") && this.bindEvents(d, c.event))
        },
        places: function(a, b) {
            var d = this,
                c = {},
                c = b.hasOwnProperty("places") ? b.places : {},
                e = k.extend({}, {
                    location: a.getCenter(),
                    radius: 100
                }, c),
                f = 0;
            "undefined" !== typeof google.maps.places && e.hasOwnProperty("query") && (c = new google.maps.places.PlacesService(a), c.textSearch(e, function(b, c) {
                if (c === google.maps.places.PlacesServiceStatus.OK &&
                    (d.places = b, e.hasOwnProperty("createMarker") && !0 === e.createMarker))
                    for (f = b.length - 1; 0 <= f; --f) b[f].hasOwnProperty("geometry") && d._markers.push(new google.maps.Marker({
                        map: a,
                        position: b[f].geometry.location
                    }))
            }))
        },
        geoLocation: function(a, b) {
            try {
                var d = this,
                    c = navigator.geolocation,
                    e = {};
                c && (b.hasOwnProperty("geolocation") && (e = k.extend({}, {
                    maximumAge: 6E5,
                    timeout: 3E3,
                    enableHighAccuracy: !1
                }, b.geolocation)), !0 !== b.autoLocation && "function" !== typeof b.autoLocation || c.getCurrentPosition(function(c) {
                    "undefined" !==
                    typeof c && "coords" in c && "latitude" in c.coords && "longitude" in c.coords && (a.panTo(new google.maps.LatLng(c.coords.latitude, c.coords.longitude)), "function" === typeof b.autoLocation && b.autoLocation.call(d, c))
                }, function(a) {
                    console.error(a)
                }, e))
            } catch (f) {}
        },
        panTo: function(a) {
            var b = this.map,
                d = {},
                c = {};
            null !== b && "undefined" !== typeof b && (d = p(a, !0), "string" === typeof d ? (c = new google.maps.Geocoder, c.geocode({
                address: d
            }, function(a, c) {
                c === google.maps.GeocoderStatus.OK && "function" === typeof b.panTo && Array.isArray(a) &&
                    a.length ? a[0].hasOwnProperty("geometry") && b.panTo(a[0].geometry.location) : console.error(c)
            })) : "function" === typeof b.panTo && b.panTo(d));
            return this
        },
        clear: function(a) {
            var b = this._directionsMarkers,
                d = this._labels,
                c = {},
                e = {},
                f = "",
                g = 0,
                h = 0;
            "undefined" === typeof a && (a = {
                marker: [],
                label: [],
                polygon: [],
                polyline: [],
                circle: [],
                direction: [],
                kml: []
            });
            try {
                for (e in a)
                    if (Array.isArray(a[e]) && (f = "_" + e.toString().toLowerCase() + "s", Array.isArray(this[f]))) {
                        for (g = 0; g < this[f].length; g += 1)
                            if (c = this[f][g], 0 === a[e].length ||
                                ~a[e].indexOf(g) || c.hasOwnProperty("id") && 0 < c.id.length && ~a[e].indexOf(c.id)) {
                                "_markers" === f && "undefined" !== typeof d[g] && d.hasOwnProperty("div") && this._labels[g].div.remove();
                                if ("_directions" === f)
                                    for (h = b.length - 1; 0 <= h; --h) "function" === typeof b[h].setMap && (this._directionsMarkers[h].setMap(null), this._directionsMarkers.splice(h, 1));
                                "function" === typeof c.set && (c.set("visible", !1), c.set("directions", null));
                                "function" === typeof c.setMap && c.setMap(null);
                                this[f][g] = w
                            }
                        this[f] = this[f].filter(function(a) {
                            return w !==
                                a
                        })
                    }
            } catch (q) {
                console.warn(q)
            } finally {
                return k(this.container)
            }
        },
        get: function(a, b) {
            var d = [],
                c = {},
                e = {},
                f = {},
                g = "",
                h = 0;
            "undefined" === typeof a && (a = {
                marker: [],
                label: [],
                polygon: [],
                polyline: [],
                circle: [],
                direction: [],
                kml: []
            });
            try {
                if ("string" === typeof a)
                    if (~a.indexOf(","))
                        for (d = a.replace(/\s/gi, "").split(","), h = 0; h < d.length; h += 1) g = "_" + d[h].toString().toLowerCase() + "s", c[d[h]] = this[g];
                    else g = "_" + a.toString().toLowerCase() + "s", c = this[g];
                else
                    for (f in a)
                        if (Array.isArray(a[f]) && (g = "_" + f.toString().toLowerCase() +
                                "s", Array.isArray(this[g])))
                            for (c[f] = [], h = 0; h < this[g].length; h += 1) e = this[g][h], (0 === a[f].length || ~a[f].indexOf(h) || e.hasOwnProperty("id") && 0 < e.id.length && ~a[f].indexOf(e.id)) && c[f].push(e);
                        "function" === typeof b && b.call(this, c)
            } catch (k) {
                console.warn(k)
            } finally {
                return c
            }
        },
        modify: function(a) {
            var b = [],
                d = [
                    ["kml", "kml"],
                    ["marker", "markers"],
                    ["direction", "direction"],
                    ["polyline", "drawPolyline"],
                    ["polygon", "drawPolygon"],
                    ["circle", "drawCircle"],
                    ["streetView", "streetView"],
                    ["markerFitBounds", "markerFitBounds"]
                ],
                c = 0,
                e = this.map;
            if ("undefined" !== typeof a) {
                for (c = d.length - 1; 0 <= c; --c) a.hasOwnProperty(d[c][0]) && b.push(d[c][1]);
                if (null !== e) {
                    if (b.length)
                        for (c = b.length - 1; 0 <= c; --c) "function" === typeof this[b[c]] && ("streetView" === b[c] && (a.streetViewObj = a.streetView, delete a.streetView), this[b[c]](e, a, "modify"));
                    else e.setOptions(a);
                    a.hasOwnProperty("event") && this.bindEvents(e, a.event);
                    google.maps.event.trigger(e, "resize")
                }
            }
            return k(this.container)
        },
        destroy: function() {
            var a = k(this.container);
            a.length && k.removeData(this.container,
                "tinyMap");
            return a.empty()
        },
        getKML: function(a) {
            var b = k(this.container).data("tinyMap");
            a = k.extend({}, {
                marker: !0,
                polyline: !0,
                direction: !0,
                download: !1
            }, a);
            var d = '<?xml version="1.0" encoding="UTF-8"?>;<kml xmlns="http://earth.google.com/kml/2.2">;<Document>;<name><![CDATA[]]\x3e</name>;<description><![CDATA[]]\x3e</description>;<Style id="style1">;<IconStyle>;<Icon>;<href>//maps.google.com/mapfiles/kml/paddle/grn-circle_maps.png</href>;</Icon>;</IconStyle>;</Style>;#PLACEMARKS#;</Document>;</kml>'.split(";"),
                c = "<Placemark> <name><![CDATA[]]\x3e</name> <Snippet></Snippet> <description><![CDATA[]]\x3e</description> <styleUrl>#style1</styleUrl> <ExtendedData> </ExtendedData> #DATA# </Placemark>".split(" "),
                e = [],
                f = [],
                f = [],
                g = "",
                h = "",
                q = "",
                n = "",
                n = "",
                l = [],
                p = [],
                l = {},
                m = 0,
                r = e = -1,
                u = -1;
            if (b) {
                if (!0 === a.marker)
                    for (e = b._markers, m = length - 1; 0 <= m; --m) n = e[m].position.lng() + "," + e[m].position.lat(), g += c.join("").replace(/#DATA#/gi, "<Point><coordinates>#LATLNG#,0.000000</coordinates></Point>".replace(/#LATLNG#/gi, n));
                if (!0 ===
                    a.polyline)
                    for (f = b._polylines, m = f.length - 1; 0 <= m; --m) {
                        l = f[m].getPath().getArray();
                        n = "";
                        for (e = l.length - 1; 0 <= e; --e) n += l[e].lng() + "," + l[e].lat() + ",0.000000\n";
                        h += c.join("").replace(/#DATA#/gi, "<LineString><tessellate>1</tessellate><coordinates>#LATLNG#</coordinates></LineString>".replace(/#LATLNG#/gi, n))
                    }
                if (!0 === a.direction)
                    for (f = b._directions, m = f.length - 1; 0 <= m; --m)
                        if (f[m].hasOwnProperty("directions") && f[m].directions.hasOwnProperty("routes") && Array.isArray(f[m].directions.routes) && 0 < f[m].directions.routes.length &&
                            f[m].directions.routes[0].hasOwnProperty("legs") && Array.isArray(f[m].directions.routes[0].legs))
                            for (l = f[m].directions.routes[0].legs, e = l.length - 1; 0 <= e; --e)
                                if (Array.isArray(l[e].steps))
                                    for (r = l[e].steps.length - 1; 0 <= r; --r) {
                                        n = "";
                                        if (Array.isArray(l[e].steps[r].path))
                                            for (u = l[e].steps[r].path.length - 1; 0 <= u; --u) p = l[e].steps[r].path[u], "undefined" !== typeof p && "function" === typeof p.lat && (n += p.lng() + "," + p.lat() + ",0.000000\n");
                                        q += c.join("").replace(/#DATA#/gi, "<LineString><tessellate>1</tessellate><coordinates>#LATLNG#</coordinates></LineString>".replace(/#LATLNG#/gi,
                                            n))
                                    }
                                n = d.join("").replace(/#PLACEMARKS#/gi, g + h + q);
                if (!0 === a.download) t.open("data:application/vnd.google-earth.kml+xml;charset=utf-8;base64," + t.btoa(t.decodeURIComponent(t.encodeURIComponent(n))));
                else return n
            }
        },
        init: function() {
            var a = this,
                b = {},
                b = {},
                d = k.extend({}, r),
                c = d.api.split("?")[0],
                e = "",
                f = {};
            try {
                delete d.api, delete d.clusterer, d = k.param(d)
            } catch (g) {}
            z || "undefined" !== typeof t.google || (b = v.createElement("script"), b.setAttribute("src", [c, d].join("?")), (v.getElementsByTagName("head")[0] || v.documentElement).appendChild(b),
                z = !0, b = null);
            A || "undefined" !== typeof MarkerClusterer || (b = v.createElement("script"), b.setAttribute("src", r.clusterer), (v.getElementsByTagName("head")[0] || v.documentElement).appendChild(b), A = !0, b = null);
            if ("object" === typeof t.google) {
                a.bounds = new google.maps.LatLngBounds;
                u = function(a) {
                    var b = a.hasOwnProperty("css") ? a.css.toString() : "";
                    this.setValues(a);
                    this.span = k("<span/>").css({
                        position: "relative",
                        left: "-50%",
                        top: "0",
                        "white-space": "nowrap"
                    }).addClass(b);
                    this.div = k("<div/>").css({
                        position: "absolute",
                        display: "none"
                    });
                    this.span.appendTo(this.div)
                };
                u.prototype = new google.maps.OverlayView;
                u.prototype.onAdd = function() {
                    this.div.appendTo(k(this.getPanes().overlayLayer));
                    this.listeners = [google.maps.event.addListener(this, "visible_changed", this.onRemove)]
                };
                u.prototype.draw = function() {
                    var a = this.getProjection(),
                        b = {};
                    try {
                        b = a.fromLatLngToDivPixel(this.get("position")), this.div.css({
                            left: b.x + "px",
                            top: b.y + "px",
                            display: "block"
                        }), this.text && this.span.html(this.text.toString())
                    } catch (c) {
                        console.error(c)
                    }
                };
                u.prototype.onRemove =
                    function() {
                        k(this.div).remove()
                    };
                for (f in a.options) a.options.hasOwnProperty(f) && (vo = a.options[f], /ControlOptions/g.test(f) && vo.hasOwnProperty("position") && "string" === typeof vo.position && (a.options[f].position = google.maps.ControlPosition[vo.position.toUpperCase()]));
                a.googleMapOptions = a.options;
                a.options.hasOwnProperty("streetView") && (a.googleMapOptions.streetViewObj = a.options.streetView, delete a.googleMapOptions.streetView);
                a.googleMapOptions.center = p(a.options.center, !0);
                a.options.hasOwnProperty("styles") &&
                    ("string" === typeof a.options.styles && y.hasOwnProperty(a.options.styles) ? a.googleMapOptions.styles = y[a.options.styles] : Array.isArray(a.options.styles) && (a.googleMapOptions.styles = a.options.styles));
                "string" === typeof a.options.center ? (b = new google.maps.Geocoder, b.geocode({
                    address: a.options.center
                }, function(b, c) {
                    try {
                        c === google.maps.GeocoderStatus.OVER_QUERY_LIMIT ? t.setTimeout(function() {
                                a.init()
                            }, a.interval) : c === google.maps.GeocoderStatus.OK && Array.isArray(b) ? 0 < b.length && b[0].hasOwnProperty("geometry") &&
                            (a.googleMapOptions.center = b[0].geometry.location, a.map = new google.maps.Map(a.container, a.googleMapOptions), google.maps.event.addListenerOnce(a.map, "idle", function() {
                                a.overlay();
                                google.maps.event.trigger(a.map, "resize")
                            }), a.bindEvents(a.map, a.options.event)) : (e = (a.options.notFound || c).toString(), a.container.innerHTML(k("<div/>").text(e).html()), console.error("Geocoder Error Code: " + c))
                    } catch (d) {
                        console.error(d)
                    }
                })) : (a.map = new google.maps.Map(a.container, a.googleMapOptions), google.maps.event.addListenerOnce(a.map,
                    "idle",
                    function() {
                        a.overlay();
                        google.maps.event.trigger(a.map, "resize")
                    }), a.bindEvents(a.map, a.options.event))
            }
        }
    };
    k.fn.tinyMapConfigure = function(a) {
        r = k.extend(r, a)
    };
    k.fn.tinyMapDistance = function(a, b) {
        var d = {
                key: r.hasOwnProperty("key") ? r.key : "",
                origins: [],
                destinations: [],
                language: "zh-TW"
            },
            d = k.extend({}, d, a);
        Array.isArray(d.origins) && (d.origins = d.origins.join("|"));
        Array.isArray(d.destinations) && (d.destinations = d.destinations.join("|"));
        k.getJSON("//maps.googleapis.com/maps/api/distancematrix/json",
            d,
            function(a) {
                "OK" === a.status && b(a)
            })
    };
    k.fn.tinyMapQuery = function(a, b) {
        var d = {
                key: r.hasOwnProperty("key") ? r.key : "",
                language: "zh-TW"
            },
            c = k.extend({}, d, a),
            e = null;
        k.getJSON("//maps.googleapis.com/maps/api/geocode/json", c, function(a) {
            "OK" === a.status && a.results && "undefined" !== typeof a.results[0] && (c.hasOwnProperty("latlng") ? e = a.results[0].formatted_address : c.hasOwnProperty("address") && (e = [a.results[0].geometry.location.lat, a.results[0].geometry.location.lng].join()), b(e))
        })
    };
    k.fn.tinyMap = function(a) {
        var b = {},
            d = [],
            c = arguments;
        return "string" === typeof a ? (this.each(function() {
            b = k.data(this, "tinyMap");
            b instanceof x && "function" === typeof b[a] && (d = b[a].apply(b, Array.prototype.slice.call(c, 1)))
        }), "undefined" !== typeof d ? d : this) : this.each(function() {
            k.data(this, "tinyMap") || k.data(this, "tinyMap", new x(this, a))
        })
    }
})(window.jQuery || {}, window, document);
